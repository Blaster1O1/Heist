var shift = 0;
var alph = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
var playerCanMove = true;
var frames = 0;
var keys = [];
var scene = 'splash';
var HeistC = 0;
var gameTxtFade = 0;
var lvl = 1;
var loadMap;
var objects;
var timeLeft = 60;
var timeCnt = 0;
var cursorVisible = true;
var redTrans = 0;
var mouseIsClicked = false;
var bullets = [];
var blocks;
var collide = function(o1,o2) {
    return o1.x < o2.x + o2.w &&
   o1.x + o1.w > o2.x &&
   o1.y < o2.y + o2.h &&
   o1.h + o1.y > o2.y;
};    
var collidingWithBullet = function(obj,b,objS) {
    var s = objS || "Rect";
    if(s === "Rect") {
        var DeltaX = b.x - max(obj.x, min(b.x, obj.x + obj.w));
        var DeltaY = b.y - max(obj.y, min(b.y, obj.y + obj.h));
    return (DeltaX * DeltaX + DeltaY * DeltaY) < (b.w/2 * b.w/2);
} else {
    var circle1 = {radius: obj.w/2,x: obj.x,y:obj.y};
    var circle2 = {radius: b.w/2, x: b.x, y: b.y};

    var dx = circle1.x - circle2.x;
    var dy = circle1.y - circle2.y;
    var distance = sqrt(dx * dx + dy * dy);

    return distance < circle1.radius + circle2.radius;
}
};    

//Bullet collision with rectangle (Learn more at https://yal.cc/rectangle-circle-intersection-test/)
var changeScene = function(newScene) {
        scene = newScene;
        frames = 1;
};        
var setConfig = function(obj, config) {
    for (var propertyName in config) {
        obj[propertyName] = config[propertyName];
    }
}; //Override some properties
var exactDistance = function(x1, y1, x2, y2) {
    return sqrt(abs((x2 - x1) * (x2 - x1)) + abs((y1 - y2) * (y1 - y2)));
};
var colorArray = function (col) {
    switch (col) {
        case 1:
            return [255, 0, 0];
        case 2:
            return [0, 255, 0];
        case 3:
            return [0, 0, 255];
    }
};
var fonts = {
    // All the fonts used in the program - defined here so they're only created once 
    arial: createFont('Arial'),
    arialBoldItalic: createFont('Ari  al Bold Italic'),
    chalkboard: createFont('Chalkboard'),
    sans: createFont('sans-serif'),
    serif: createFont('serif'),
    tahoma: createFont('Tahoma'),
    times: createFont('Times'),
    verdana: createFont('Verdana'),
    avenir: createFont('avenir'),
    monospace: createFont('monospace'),
    oribtron: createFont('Orbitron'),
    tooltip: createFont('Verdana', 12),
};
var mouse = {

    get x() {
        return mouseX;
    },
    get y() {
        return mouseY;
    },

    // return `true` if the mouse is inside the defined rectangle/square
    isInRect: function(left, top, width, height) {
        // if `height` is not passed, assume a square with all sides of length `width`
        if (arguments.length < 4) {
            height = width;
        }
        return this.x >= left &&
            this.x < left + width &&
            this.y >= top &&
            this.y < top + height;
    },

    // return `true` if the mouse is inside the defined ellipse/circle
    isInEllipse: function(centerX, centerY, width, height) {
        // if `height` is not passed, assume a circle with a diameter of `width`
        if (arguments.length < 4) {
            height = width;
        }
        return sq((this.x - centerX) / (width / 2)) + sq((this.y - centerY) / (height / 2)) <= 1;
    }
}; {
    var textType = { // indicates the kind of data accepted into a `Textbox` object

        DIGITS: /\d/, // digits (0..9)
        ALPHA: /[a-z]/i, // letters, case insensitive
        ALPHANUMERIC: /[a-z\d]/i, // letters and digits, case insensitive
        ANYTHING: /[ -~]/ // anything from space to tilde (' '..'~')
    };

    var Textbox = function(owner, left, top, width, height, textType, maxChars, caption, config) {
        this.owner = owner; // object that owns this textbox.

        this.left = left; // location of textbox & selection area for mouse.
        this.top = top;
        this.width = width;
        this.height = height;

        this.validRegExp = textType; // RegExp of acceptable characters
        this.maxChars = maxChars; // not more than `maxChars` characters will be allowed
        { // object defaults - may be overridden by 'config' parameter
            this.xAlign = LEFT; // only valid values are `LEFT` and `CENTER`.  Currently no support for `RIGHT`
            this.caption = caption; // caption that will be drawn to the left of the textbox
            this.text = ''; // starting value
            this.isVisible = true; // allow button to be shown/drawn
            this.isEnabled = true; // allow button to be selected and typed-into
            this.foreColor = color(0);
            this.font = fonts.serif;
            this.fontSize = 26;
            this.captionColor = this.foreColor;
            this.captionFont = this.font;
            this.captionFontSize = this.fontSize;

            this.enterEqualsTab = true; // When multiple textboxes exist, pressing `ENTER` tabs to the next textbox
        }
        setConfig(this, config); // override default properties
    };
    Object.defineProperty(Textbox.prototype, 'mouseIsOver', {
        get: function() {
            return this.isEnabled && this.isVisible && mouse.isInRect(this.left, this.top, this.width, this.height);
        }
    });

    Textbox.prototype.draw = function() {
        if (!this.isVisible) {
            return;
        }

        // caption

        if (this.caption && this.captionColor && this.captionFont && this.captionFontSize) {
            textAlign(RIGHT, CENTER);
            textFont(this.captionFont, this.captionFontSize);
            fill(this.captionColor);
            text(this.caption, this.left, this.top + this.height / 2);
        }

        // text

        // is this the "current textbox"?
        var isCurrent = this.owner && this.owner.textboxes && this.owner.textboxes[this.owner.textIndex] === this;
        textAlign(this.xAlign, CENTER);
        textFont(this.font, this.fontSize);
        fill(this.foreColor);
        // append a blinking "cursor" & to "current textbox"
        text(this.text + (isCurrent && frameCount % 60 < 30 ? '|' : ' '),
            this.xAlign === LEFT ? this.left : this.left + this.width / 2,
            this.top + this.height / 2);
    };
} // textType & Textbox
var tooltip = {
    x: undefined,
    y: undefined,
    w: undefined,
    h: undefined,
    txt: undefined,
    time: 0,
    isVisible: false,
    draw: function() {
        if (this.isVisible) {
            stroke(0, 0, 0);
            fill(255, 255, 0, 210);
            rect(this.x, this.y, this.w, this.h);
            fill(0, 0, 0, 225);
            text(this.txt, this.x + 5, this.y + 5);
        }

    },
    update: function() {
        if (mouse.isInRect(this.x, this.y, this.w, this.h)) {
            this.time++;
        } else {
            this.time = 0;
        }
        if (this.time >= 70) {
            this.isVisible = true;
        }
    }
}; //Tooltip

{ //Button
    var buttonShape = { // possible shapes of a button
        RECTANGLE: 0,
        ELLIPSE: 1
    };
    var Button = function(x, y, width, height, caption, onClick, config) {
        // If button's shape is ELLIPSE, (x,y) are the center coordinates.
        // If button's shape is RECTANGLE, (x,y) are the top/left coordinates.
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.caption = caption;
        this.onClick = typeof onClick === 'function' ? onClick : function() {}; { // object defaults - may be overridden by 'config' parameter
            this.isVisible = true; // allow button to be shown/drawn
            this.isEnabled = true; // allow button to be clicked
            this.shape = buttonShape.RECTANGLE;
            this.toolTipText = this.caption;
            this.borderSize = 1; // the stroke weight of the button's border
            this.radius = this.height / 4; // only valid for `RECTANGLE` shaped buttons
            // if a certain color is not wanted (e.g., no border), use `undefined` as the color value
            this.backColor = color(181); // the fill color of the button's shape
            this.borderColor = color(255, 255, 255); // the stroke color of the button's shape
            this.foreColor = color(0); // the color of the caption
            this.inverseOnMouseOver = true; // draw using 'inverse' colors when mouse is over button
            this.inverseBackColor = color(255, 0, 0);
            this.inverseBorderColor = color(255, 0, 0);
            this.inverseForeColor = this.foreColor;
            this.inverseBorderSize = this.borderSize + 2;
            this.font = fonts.chalkboard;
            this.fontSize = 22;
            this.time = 0;
        }
        setConfig(this, config); // override default properties
    };

    Object.defineProperty(Button.prototype, 'mouseIsOver', {

        get: function() {
            return this.isEnabled && this.isVisible &&
                (this.shape === buttonShape.RECTANGLE ?
                    mouse.isInRect(this.x, this.y, this.width, this.height) :
                    mouse.isInEllipse(this.x, this.y, this.width, this.height));

        }

    });

    Button.prototype.draw = function() {
        if (!this.isVisible) {
            return;
        }
        var useInverse = this.inverseOnMouseOver && this.mouseIsOver;
        var backColor = useInverse ? this.inverseBackColor : this.backColor;
        var borderColor = useInverse ? this.inverseBorderColor : this.borderColor;
        var foreColor = useInverse ? this.inverseForeColor : this.foreColor;
        var borderSize = useInverse ? this.inverseBorderSize : this.borderSize;
        tooltip.txt = this.toolTipText;
        tooltip.x = this.x + 5;
        tooltip.y = this.y + 6;
        tooltip.w = 30;
        tooltip.h = 10;
        if (borderColor && borderSize) {

            strokeWeight(borderSize);
            stroke(borderColor);
        } else {
            noStroke();
        }
        if (backColor) {
            fill(backColor);
        } else {
            noFill();
        }
        if (this.shape === buttonShape.RECTANGLE) {
            rect(this.x, this.y, this.width, this.height, this.radius);
        } else {
            ellipse(this.x, this.y, this.width, this.height);
        }

        if (this.caption !== undefined && this.caption !== '' && foreColor !== undefined && this.font && this.fontSize > 0) {
            var centerX = this.shape === buttonShape.RECTANGLE ? this.x + this.width / 2 : this.x;
            var centerY = this.shape === buttonShape.RECTANGLE ? this.y + this.height / 2 : this.y;
            fill(foreColor);
            textFont(this.font, this.fontSize);
            textAlign(CENTER, CENTER);
            text(this.caption, centerX, centerY);
        }
    };

}

var menuBtns = [
  new Button(300, 300, 60, 60, "PLAY", function() {changeScene('game');}, {shape: buttonShape.ELLIPSE}) 
]; {
    var FireParticle = function(x, y, life, speed, maxLife) {
        this.x = x;
        this.y = y;
        this.life = life;
        this.speed = speed;
        this.maxLife = maxLife;
    };

    FireParticle.prototype.draw = function() {
        var factor = (this.life--) / this.maxLife;
        fill(255, factor * 255, sin(factor * 20) * 255, factor * 255); // Reduce the 28 to get more yellow/orange in the flame
        ellipse(this.x, this.y, 25, random(20)); // Increase 18 to change the density/blur of the fire trail - try 25 or 30!
        this.x -= this.speed;
    };

    var fire = {
        maxLife: 40,
        x: 200,
        y: 400,
        height: 30,
        particles: [],
        t: 0,
        draw: function() {
            this.t += 0.03;
            var val;
            for (var i = 0; i < this.height / 3.2; i++) { // lower 2.2 to get a higher particle density (may cause lag)
                val = random(-90, 90);
                var y = this.y - sin(val) * this.height / 2;
                var x = this.x + cos(val) * this.height / 4;
                val = noise(y / 100, this.t, 0);
                var life = this.maxLife * (0.8 * (1 - abs((this.y - y) / this.height * 2)) + val - 0.3); // Reduce the 0.3 to get a denser flame (may cause lag)
                var speed = val * random(3, 5) + 4; // Increase 4 to increase tail length & the appearance of speed
                this.particles.push(new FireParticle(x + random(0, this.height / 4), y, life, speed, this.maxLife));
            }
            val = map(noise(this.t / 20, 0, 0), 0, 1, -3, 3); // -3, 3 are the limits of up & down tail "wag"
            noStroke();
            for (var i = this.particles.length - 1; i >= 0; i--) {
                this.particles[i].draw();
                this.particles[i].y += val;
                if (this.particles[i].life <= 0) {
                    this.particles.splice(i, 1);
                }
            }
        }
    };
} // FireParticle & fire
var shadowText = function(txt, x, y, textColor, shadowColor, offSet, txtSize) {
    this.txt = txt;
    this.x = x;
    this.y = y;
    this.offSet = offSet;
    this.txtSize = txtSize;

    this.textColor = textColor;
    this.shadowColor = shadowColor;

    textAlign(CENTER);
    textSize(this.txtSize);
    fill(this.shadowColor);
    text(this.txt, (this.x + this.offSet), (this.y + this.offSet));
    fill(this.textColor);
    text(this.txt, this.x, this.y);
}; //By awk

var selfTypingText = function(t, x, y, color, speed, delay, depth) {
    //by Knowledge
    if (depth) {
        fill(0, 0, 0);
        text(t.substring(0, floor(frameCount / speed) - delay), x - 1, y - 2, width, height);
    }
    fill(color);
    text(t.substring(0, floor(frameCount / speed) - delay), x, y, width, height);
};
// return `true` when it's time to leave the splash screen
var drawLogo = function() {
    // does this function need to be initialized?
    if (!drawLogo.initialized) {
        drawLogo.startTime = millis(); // used for timimg the animation & duration of the splash screen
        drawLogo.dismiss = false; // this will become `true` when it's time to leave the splash screen
        drawLogo.buttons = [
            new Button(1, 560, 80, 30, 'Skip', function() {
                drawLogo.dismiss = true;
            })
        ];
        drawLogo.pos = 400;
        drawLogo.stars = [];
        drawLogo.initialized = true;
    }

    drawLogo.pos /= 1.2;
    if (drawLogo.stars.length < 30) {
        drawLogo.stars.push({
            x: random(0, 600),
            y: random(0, 600),
            life: floor(random(40, 160)),
            size: random(1, 3)
        });
    }

    // After 400 frames (~6.7 seconds), the splash screen will be dismissed - unless it's already been dismissed via the "skip" button
    drawLogo.dismiss = drawLogo.dismiss || (frames >= 400);

    background(17, 17, 36); // "midnight blue"

    // stars
    noFill();
    drawLogo.stars.forEach(function(star, i, stars) {
        (stroke)(255, map(star.life, 0, 80, 0, 255));
        strokeWeight(star.size);
        point(star.x, star.y);
        if (--star.life <= 0) {
            stars.splice(i, 1);
        }
    });

    // "Startech"
    noStroke();
    fill(192);
    textAlign(CENTER, CENTER);
    textFont(fonts.tahoma, 96);
    text("S", 165 + drawLogo.pos, 250);
    textSize(64);
    text('TARTECH', 325 + drawLogo.pos, 260);

    // "burning" square
    for (var x = 0; x < 4; x++) {
        for (var y = 0; y < 4; y++) {
            fill(242, y * 64 + sin(x * 140 + frames * 10) * 64, 0, y * 128 + 64);
            ellipse(x * 5 + 115 + drawLogo.pos, y * 5 + 215 + drawLogo.pos, 5, 5);
        }
    }

    // "Infinity" sphere
    fill(255, 255, 128, 32);
    ellipse(300 + sin(frames) * 100, 300 + sin(frames * 2) * 50 + drawLogo.pos, 120, 120);

    // Fireball
    var y = constrain(map(frames, 0, 180, 200, 100), 100, 200); // Change 100s to move star's final y-position
    var x = constrain(map(frames, 0, 180, -30, 280), -30, 280); // Change 280s to move star's final x-position
    noStroke();
    for (var d = 30; d > 0; d -= 2) {
        fill(lerpColor(color(255, 0, 0), color(255, 255, 0), d / 30));
        ellipse(x, y, d, d);
    }
    fire.x = x;
    fire.y = y;
    fire.draw();

    // "Presents..." & motto
    fill(255, 255, 255, map(frames, 200, 300, 0, 255));
    textFont(fonts.arial, 38);
    text("Presents...", 293 + drawLogo.pos, 560);
    selfTypingText("Our motto: Create the best, or nothing.", 0, 69, color(255), 4, 7, false);

    // draw buttons
    drawLogo.buttons.forEach(function(button) {
        button.draw();
    });
    return drawLogo.dismiss;
};
var pSystems = [];
var SprayPSystem = function (x, y, col) {
    this.x = x;
    this.y = y;
    this.particles = [];
    // adds the particles
    var speed = 2;
    for (var i = 0; i < 5; i++) {
        var p = {'x': this.x, 'y': this.y, 
                 'xVel': random(-speed, speed), 'yVel': random(-speed, speed), 
                 'size': random(3)+3,
                 'a': random(100)+155,
                 // darkens the color by a random value from 1-100
                 'col': [constrain(round(col[0]-random(100)), 0, 255),
                         constrain(round(col[1]-random(100)), 0, 255),
                         constrain(round(col[2]-random(100)), 0, 255)],
        };
         
        this.particles.push(p);
    }
    this.run = function () {
        noStroke();
        for (var i = 0; i < this.particles.length; i++) {
            var p = this.particles[i];
            
            fill(p.col[0], p.col[1], p.col[2], p.a);
            ellipse(p.x, p.y, p.size, p.size);

            
            p.x += p.xVel;
            p.y += p.yVel;
            p.a -= 5;
            
            if (p.a <= 0) {
                this.particles.splice(i, 1);
                i--;
            }
        }
        return this.particles.length === 0;
    };
};
var addParticleSystem = function(type, info) {
    switch (type) {
        case 'bullet-collision':
            pSystems.push(new SprayPSystem(info.x, info.y, info.col));
            break;
    }
};

var plr = {
    x: 0, y: 0,
    w: 20, h: 20,
    score: 0,
    xvel: 0,
    yvel: 0,
    funds: 0,
    health:100,
    fundsInLevel: 0,
    maxHealth:100,
    falling: true,
    gravity: 0.4,
    jumpHeight: 9,
    maxFallSpeed : 12,
    moveSpeed: 0.5,
    maxMoveSpeed: 5,
    direction: "",
    update: function(platforms,lockedDoors) {
       // println(this.direction);
        /* Player Events */
        if(playerCanMove){if(keys[LEFT]) { this.xvel -= this.moveSpeed; this.direction = "left"; }
        if(keys[RIGHT]){ this.xvel += this.moveSpeed; this.direction = "right"; }
           if(this.y >= 600) {
                this.died();
            }
        
        if(!keys[LEFT] && !keys[RIGHT]) {
            if(this.xvel>0) {
                this.xvel -= this.moveSpeed;
            }
            if(this.xvel<0) {
                this.xvel += this.moveSpeed;
            }
            /*A quick fix to stop player from
                moving in a single direction.*/
            if(this.xvel<0.1&&this.xvel>0){this.xvel=0;}
            if(this.xvel>-0.1&&this.xvel<0){this.xvel=0;}
        }

        // Checks if we're able to jump
        if(keys[UP] && !this.falling) {
            this.yvel = -this.jumpHeight;
        }
        
        // Adds gravity to player
        this.yvel += this.gravity;
        
        // Checks x and y max velocity speeds
        if(this.yvel > this.maxFallSpeed) {
            this.yvel = this.maxFallSpeed;}
        
        if(this.xvel > this.maxMoveSpeed) {
            this.xvel = this.maxMoveSpeed;}
            
        if(this.xvel < -this.maxMoveSpeed) {
            this.xvel = -this.maxMoveSpeed;}
        
        
        this.x += this.xvel;}
        // Checks LEFT and RIGHT cofllision
        this.collideWith(this.xvel,0,platforms,lockedDoors);
        

        // Always asume that the player is in the air.
        // NOTE: This will be set to false if the collideWith function
        //       finds that the player is on a platform.
        this.falling = true; 
        
        
        this.y += this.yvel;
        // Checks TOP and BOTTOM collision
        this.collideWith(0,this.yvel,platforms,lockedDoors);
        for(var i = 0; i < bullets.length; i++) {
            if(collidingWithBullet(this,bullets[i]) && bullets[i].o!==this) {
            addParticleSystem('bullet-collision',{'x': bullets[i].x, 'y': this.y, 'col': colorArray(2)});
            if(this.health > 0) {
                this.health -= bullets[i].dmg;
            }
            if(this.health === 0) {
                this.health = this.maxHealth;
                objects.remove();
                loadMap();
            }
            redTrans = 80;
            bullets.splice(i,1);
            }
        }
        
    },
    
    collideWith: function(xv,yv,platforms,lockedDoors) {
        for (var i = 0; i < platforms.length; i++) {
            var p = platforms[i];
            if( this.y+this.h > p.y &&
                this.y        < p.y+p.h &&
                this.x+this.w > p.x &&
                this.x        < p.x+p.w)
            {
                // BOTTOM
                if(yv>0) {
                    this.yvel = 0;
                    this.falling = false;
                    this.y = p.y-this.h;
                }
                // TOP
                if(yv<0) {
                    this.yvel = 0;
                    this.falling = true;
                    this.y = p.y+p.h;
                }
                // RIGHT
                if(xv>0) {
                    this.xvel = 0;
                    this.x = p.x-this.w;
                }
                // LEFT
                if(xv<0) {
                    this.xvel = 0;
                    this.x = p.x+p.w;
                }
            }
        }
        for (var i = 0; i < lockedDoors.length; i++) {
            var ld = lockedDoors[i]; 
            if( this.y+this.h > ld.y &&
                this.y        < ld.y+ld.h &&
                this.x+this.w > ld.x &&
                this.x        < ld.x+ld.w)
            {
            if(xv>0) {
                this.xvel = 0;
                this.x = ld.x-this.w;
            }
                // LEFT
            if(xv<0) {
                this.xvel = 0;
                this.x = ld.x+ld.w;
            }
            }
        }
    },
    
    draw : function() {
        noStroke();
        fill(252, 247, 154, frameCount * 2);
        rect(this.x, this.y, this.w, this.h);
        fill(0, 0, 0, frameCount * 2);
        rect(this.x, this.y + this.w / 1.8, this.w, this.h / 2.2);
        rect(this.x, this.y, this.w, this.h / 5);
        fill(255, 0, 255, frameCount * 2);
        ellipse(sin(frameCount * 6) + this.x + this.w / 4, this.y + this.h / 2.8, this.w / 4, this.h / 4);
        ellipse(sin(frameCount * 6) + this.x + this.w - this .w / 4, this.y + this.h / 2.8, this.w / 4, this.h / 4);
        //Health bar
        if(this.health < this.maxHealth) {
            fill(182);
            rect(this.x - 35,this.y - 10,this.maxHealth,4);
            fill(255, 0, 0);
            rect(this.x - 35,this.y - 10,this.health,4);
        }
    },
    died: function() {
        this.funds -= this.fundsInLevel;
        this.fundsInLevel = 0;
        objects.remove();
        loadMap();
        gameTxtFade = 1;
    }
    
};

var addBullet = function(x,y,size,xVel,yVel,col,dmg,origin) {
    var b = {
        x: x,
        y: y,
        size: size,
        xVel: xVel,
        yVel: yVel,
        col: col,
        dmg: dmg,
        o: origin
        
    };
    bullets.push(b);
};
/* Block Object */
var Block = function (x,y,w,h,c) {
    this.x = x; this.y = y;
    this.w = w; this.h = h;
    this.c = c || color(255,0,0);
};
Block.prototype.draw = function() {
    noStroke();
    fill(this.c);
    rect(this.x,this.y,this.w,this.h);
};
Block.prototype.checkBulletCollision = function() {
    for(var i = 0; i < bullets.length; i++) {
        if(collidingWithBullet(this,bullets[i])) {
            bullets.splice(i,1);
            addParticleSystem('bullet-collision',{'x': this.x, 'y': this.y, 'col': colorArray(3)});
        }
    }
};
blocks = [];
blocks.add = function(x,y,w,h,c) {
    blocks.push(new Block(x,y,w,h,c));
};    
blocks.apply = function() {
    blocks.forEach(function(block){block.draw(); block.checkBulletCollision();});
};   
var Diamond = function(x,y,w,h) {
    this.x = x; this.y = y;
    this.w = w; this.h = h;
    this.collected = false;
}; 
Diamond.prototype.draw = function() {
    if(!this.collected) {
        fill(43, 170, 255);
        beginShape();
        var x = this.x; var y = this.y;
        var w = this.w; var h = this.h;
        vertex(x + w - (w / 4), y);
        vertex(x + w / 4, y);
        vertex(x, y + h / 4);
        vertex(x + w / 2, y + h);
        vertex(x + w, y + h / 4);
        endShape();
        
        
        fill(255, 255, 255, 80);
        beginShape();
        vertex(x + w / 4, y);
        vertex(x, y + h / 4);
        vertex(x + w / 6, y + h / 4);
        endShape();
        
        fill(255, 255, 255, 60);
        beginShape();
        vertex(x + w / 6, y + h / 4);
        vertex(x, y + h / 4);
        vertex(x + w / 2, y + h);
        endShape();
        
        
        fill(255, 255, 255, 30);
        beginShape();
        vertex(x + w / 4, y);
        vertex(x + w / 6, y + h / 4);
        vertex(x + w / 3, y + h / 4);
        endShape();
        
        fill(255, 255, 255, 30);
        beginShape();
        vertex(x + w / 3, y + h / 4);
        vertex(x + w / 6, y + h / 4);
        vertex(x + w / 2, y + h);
        endShape();
        
        fill(255, 255, 255, 10);
        beginShape();
        vertex(x + w / 4, y);
        vertex(x + w / 2, y);
        vertex(x + w / 3, y + h / 4);
        endShape();
        
        
        fill(255, 255, 255, 40);
        beginShape();
        vertex(x + w / 2, y);
        vertex(x + w / 1.5, y + h / 4);
        vertex(x + w / 3, y + h / 4);
        endShape();
        
        fill(255, 255, 255, 10);
        beginShape();
        vertex(x + w / 2, y + h);
        vertex(x + w / 1.5, y + h / 4);
        vertex(x + w / 3, y + h / 4);
        endShape();
        
        fill(0, 0, 0, 5);
        beginShape();
        vertex(x + w / 2, y + h);
        vertex(x + w, y + h / 4);
        vertex(x + w / 1.5, y + h / 4);
        endShape();
        
        fill(0, 0, 0, 15);
        beginShape();
        vertex(x + w / 1.35, y);
        vertex(x + w, y + h / 4);
        vertex(x + w / 1.5, y + h / 4);
        endShape();    
    }
};  
Diamond.prototype.update = function() {
    if(!this.collected) {
        if(collide(plr,this)) {
            this.collected = true; 
            plr.fundsInLevel += 100;
            plr.funds += 100;
        }    
    }    
};    
var diamonds = [];
diamonds.add = function(x,y,w,h) {
    diamonds.push(new Diamond(x,y,w,h));  
};    
diamonds.apply = function() {
    diamonds.forEach(function(diamond){diamond.draw(); diamond.update();});  
};
var Message = function(txt) {
    pushStyle();
    strokeWeight(4);
    stroke(102, 58, 58);
    fill(9, 141, 161);
    rect(120,50,420,200); 
    fill(255);
    textFont(fonts.arial,25);
    text(txt,100,60,450,150);
    popStyle();
};    
var Door = function(x,y) {
    this.x = x;
    this.y = y + 18;
    this.activated = false;
    this.w = 30; this.h = 60;
};    
Door.prototype.draw = function() {
    pushStyle();
    strokeWeight(3);
    stroke(182);
    fill(223);
    rect(this.x,this.y,30,60);
    noStroke();
    fill(196, 134, 33);
    ellipse(this.x + 20, this.y + 30, 8,8);
    popStyle();
};
Door.prototype.update = function() {
    if(collide(plr,this)) {
        Message("Press Space to Activate!");
        if(keys[32]) {
            lvl += 1;
            objects.remove();
            loadMap();
            plr.fundsInLevel = 0;
            timeLeft = 60;
            gameTxtFade = 1;
        }    
   }       
};    
var doors = [];
doors.add = function(x,y) {
    this.push(new Door(x,y));    
};    
doors.apply = function() {
    doors.forEach(function(door) {
        door.draw();
        door.update();
    });    
}; 
var updateBullets = function() {

    for (var i=bullets.length-1; i >= 0; i--) {
        var b = bullets[i];
        
        if (b.x < -50 || b.x > 650 || b.y < -50 || b.y > 650) {
            bullets.splice(i, 1);
            
        } else {
            b.x += b.xVel;
            b.y += b.yVel;
            
        }
        //if(true){throw "kek";}
    }
};
var drawBullets = function() {
    for (var i = 0; i < bullets.length; i++) {
        var b = bullets[i];
        fill(b.col);
        noStroke();
        ellipse(b.x, b.y, b.size, b.size);
    }
};

var Gun = function(x,y) {
    this.x = x;
    this.y = y+25;
    this.pickup={x: this.x-15,y:this.y,w:45,h:15};
    this.w = 30;
    this.h = 15;
    this.pickedup = false;
    this.delay = 5;
    this.timer = 5;
    this.reload = 10;
    this.reloadTime = 0;
    this.ammo = 10;
    this.ableToShoot = true;
};
Gun.prototype.draw = function() {
    pushMatrix();
    translate(this.x+5,this.y);
    
    scale(0.2);
    noStroke();
    fill(64, 64, 64);
    rect(-100, 0, 195, 8);
    rect(95, -1, 27, 10);
    rect(-100, 13, 217, 8);
    rect(33, -4, 5, 3);
    fill(54, 54, 54);
    rect(58, 11, 1, 12);
    rect(57, 12, 4, 10);
    rect(52, 12, 4, 10);
    rect(46, 12, 4, 10);
    rect(40, 12, 4, 10);
    
    // barrel decorations
    fill(18, 18, 18);
    ellipse(108, -1, 13, 1);
    ellipse(108, 2, 13, 1);
    ellipse(108, 5, 13, 1);
    ellipse(108, 8, 13, 1);
    fill(97, 97, 97);
    rect(-20, -2, 60, 21);
    fill(84, 84, 84);
    rect(-25, -2, 60, 27);
    triangle(35, 15, 35, 25, 42, 20);
    rect(35, 22, 7, 5);
    fill(97, 97, 97);
    triangle(25, 4, 35, 4, 35, 9);
    fill(97, 97, 97);
    rect(-20, -2, 60, 7);
    stroke(51, 51, 51);
    strokeWeight(2);
    line(35, 11, 38, 11);
    line(35, 14, 38, 14);
    noStroke();
    fill(0, 0, 0);
    ellipse(30, 1, 10, 2);
    ellipse(18, 1, 10, 2);
    ellipse(6, 1, 10, 2);
    
    // pump action part decorations
    strokeWeight(1);
    stroke(94, 94, 94);
    line(19, 7, 19, 21);
    line(15, 7, 15, 21);
    line(11, 7, 11, 21);
    line(7, 7, 7, 21);
    line(3, 7, 3, 21);
    noStroke();
    fill(71, 71, 71);
    rect(-5, 24, 15, 3);
    rect(-2, 26, 8, 30);
    stroke(51, 51, 51);
    strokeWeight(1);
    line(-2, 34, 5, 34);
    line(-2, 36, 5, 36);
    line(-2, 38, 5,38);
    line(-2, 40, 5, 40);
    line(-2, 42, 5, 42);
    line(-2, 44, 5, 44);
    line(-2, 46, 5, 46);
    line(-2, 48, 5, 48);
    popMatrix();
};
Gun.prototype.update = function() {
    if(this.pickedup) {
        this.x = plr.x + plr.w;
        this.y = plr.y;
        if (this.ammo > 0) {
            this.ableToShoot = true;
        }
        if (this.timer < this.delay) {
            this.ableToShoot = false;
        }
        if (this.ammo <= 0) {
            if (this.reloadTime >= this.reload) {
                this.ammo = 0;
                this.reloadTime = 0;
            } else {
                this.reloadTime++;
            }
        }
        if (mouseIsClicked && this.ammo > 0 && this.ableToShoot === true) {
            var cursorXDist = -(this.x+25) + mouseX;
            var cursorYDist = -(this.y) + mouseY;
            var magnitude = sqrt(sq(cursorXDist) + sq(cursorYDist));
            addBullet(this.x+25,
                this.y,
                9,
                cursorXDist / magnitude * 5,
                cursorYDist / magnitude * 5,
                color(0),
                10, plr);
        }
    }
    else { 
        if(collide(plr,this.pickup)) {
            this.pickedup = true;    
        }
    }    
};
var guns = [];
guns.add = function(x,y) {
    this.push(new Gun(x,y));    
};
guns.apply = function() {
    guns.forEach(function(gun){gun.draw();gun.update();});   };
var Guard = function(x,y) {
    this.x = x;
    this.y = y + 20;
    this.w = 20; 
    this.h = 20;
    this.maxHealth = 20;
    this.health = 20;
    this.dead = false;
    this.xvel = 2;
};
Guard.prototype.draw = function() {
    if(!this.dead) {
        //Basically same as player, but a different color
        noStroke();
        fill(252, 247, 154, frameCount * 2);
        rect(this.x, this.y, this.w, this.h);
        fill(255,255,0, frameCount * 2);
        rect(this.x, this.y + this.w / 1.8, this.w, this.h / 2.2);
        rect(this.x, this.y, this.w, this.h / 5);
        fill(255, 0, 255, frameCount * 2);
        ellipse(sin(frameCount * 6) + this.x + this.w / 4, this.y + this.h / 2.8, this.w / 4, this.h / 4);
        ellipse(sin(frameCount * 6) + this.x + this.w - this.w / 4, this.y + this.h / 2.8, this.w / 4, this.h / 4);
        
        //Health bar
        if(this.health < this.maxHealth) {
            fill(182);
            rect(this.x,this.y - 10,this.maxHealth,4);
            fill(255, 0, 0);
            rect(this.x,this.y - 10,this.health,4);
        }
    }
};
Guard.prototype.update = function() {
    for(var i = 0; i < bullets.length; i++) {
        if(collidingWithBullet(this,bullets[i])) {
            var b = bullets[i];
            if(this.health > 0) {
                this.health -= b.dmg;
                bullets.splice(i,1);
                addParticleSystem('bullet-collision',{'x': this.x, 'y': this.y, 'col': colorArray(1)});
            }
            if(this.health === 0) {
                this.dead = true;    
            }
        }
    }
    if(collide(plr,this) && !this.dead) {
        objects.remove();
        loadMap();    
        gameTxtFade = 1;
    }
    for(var i=0;i<blocks.length;i++){
        if(collide(this, blocks[i])){
            this.xvel=-this.xvel;
        }
    }
    this.x += this.xvel;
};
var guards = [];
guards.add = function(x,y) {
    this.push(new Guard(x,y));    
};
guards.apply = function() {
    this.forEach(function(guard){guard.draw();guard.update();});    
};
var LockedDoor = function(x,y) {
    this.x = x+15;
    this.y = y;
    this.w = 5;
    this.h = 40;
    this.picked = false;
    this.cnt = 0;
    this.timeBeforePicked = 5;
};
LockedDoor.prototype.draw = function() {
    fill(182);
    rect(this.x,this.y,this.w,this.h);
};
LockedDoor.prototype.update = function() {
    if(plr.x+plr.w >= this.x && plr.x <= this.x + this.w && !this.picked) {
        if(plr.y >= this.y && plr.y <= this.y + this.h) {
            Message("Hold X to pick the lock!");
            if(keys[88]) {
                Message(this.timeBeforePicked);
                if(this.timeBeforePicked === 0) {
                        this.picked = true;  
                } else {
                    this.cnt++;
                    if(this.cnt >= 100) {
                        this.cnt = 0;
                        this.timeBeforePicked -= 1;
                    }
                }
            } else {
                this.timeBeforePicked = 5;    
            }
        }
    }
    if(this.picked) {
        if(this.h > 0) {
            this.h--;    
        }
    }
};
var lockedDoors = [];
lockedDoors.add = function(x,y) {
    this.push(new LockedDoor(x,y));    
};
lockedDoors.apply = function() {
    this.forEach(function(door){door.draw();door.update();});    
};
var Cannon = function(x,y,t,d) {
    this.x = x;
    this.y = y + 25;
    this.type = t || "Normal";
    this.w = 30;
    this.h = 30;
    this.dir = d || 0;
    this.angle = atan2(this.x-(plr.x +plr.w/2),plr.y-this.y);
    this.health = 50;
    this.maxHealth = 50;
    this.rectSize = {x:this.x+this.w/2-5,y:this.y+this.h/2+5,w:this.w/3,h:10};
    this.ellipseSize = {x:this.x+this.w/2,y:this.y+this.h/2,w:this.w*3/5,h:this.h*3/5};
};
Cannon.prototype.draw = function() {
    if(this.type === "Following") {
        noStroke();
        fill(80);
        ellipse(this.x+this.w/2,this.y+this.h/2,this.w*3/5,this.h*3/5);
        pushMatrix();
        translate(this.x+this.w/2,this.y+this.h/2);
        rotate(this.angle);
        rect(-5,5,this.w/3,10);
        popMatrix();
        if (this.health < this.maxHealth) {
            fill(182);
            rect(this.x - 35, this.y - 10, this.maxHealth, 4);
            fill(255, 0, 0);
            rect(this.x - 35, this.y - 10, this.health, 4);
        }
        
    } else {
        pushMatrix();
        noStroke();
        ellipse(this.x,this.y,this.w,this.h);
        if(this.dir === 0) {
            rect(this.x - 25,this.y - 5,20,10);
        } else {
            rect(this.x + 5,this.y - 5,20,10);    
        }
        pushStyle();
        strokeWeight(2);
        stroke(0);
        line(this.x, this.y + 9,this.x+7,this.y+15);
        line(this.x, this.y + 10,this.x,this.y+15);
        line(this.x, this.y + 9,this.x-7,this.y+15);
        popStyle();
        popMatrix();
    }
};
Cannon.prototype.update = function() {
    this.angle = atan2(this.x-plr.x,plr.y-this.y);
    if(frameCount%100===99) {
        if(this.type === "Following") {
            var plrXDist = -(this.x+this.w/2) + (plr.x+plr.w/2);
            var plrYDist = -(this.y+this.h/2) + plr.y;
            var magnitude = sqrt(sq(plrXDist) + sq(plrYDist));
            addBullet(this.x+this.w/2,
                this.y+this.h/2,
                9,
                plrXDist / magnitude * 5,
                plrYDist / magnitude * 5,
                color(0),
                12,this);
                for(var i=0;i<bullets.length;i++){
                        if(collidingWithBullet(this.rectSize,bullets[i],"Rect") || collidingWithBullet(this.ellipseSize,bullets[i],"Ellipse")) {                   if(bullets[i].o === plr) {    
                            this.health -= bullets[i].dmg;
                            bullets.splice(i,1);
                        }
                    }
                }
        }   else {
            var xvel = 0;
            if(this.dir===0) {xvel = -2;}
            else{xvel = 2;}
            addBullet(this.x,    
                this.y,
                9,
                xvel,
                0,
                color(0),
                10,this);
        }
    }
};
var cannons = [];
cannons.add = function(x,y,t,d) {
    this.push(new Cannon(x,y,t,d));    
};
cannons.apply = function() {
    this.forEach(function(cannon){cannon.draw();cannon.update();});
};
var Gunner = function(x,y,d) {
    this.x = x;
    this.y = y;
    this.w = 40;
    this.h = 40;
    this.dir = d || 1;
};
Gunner.prototype.draw = function() {
    noStroke();
    fill(252, 247, 154, frameCount * 2);
    rect(this.x, this.y, this.w, this.h);
    fill(0, 0, 0, frameCount * 2);
    rect(this.x, this.y + this.w / 1.8, this.w, this.h / 2.2);
    rect(this.x, this.y, this.w, this.h / 5);
    fill(255, 0, 255, frameCount * 2);
    ellipse(sin(frameCount * 6) + this.x + this.w / 4, this.y + this.h / 2.8, this.w / 4, this.h / 4);
    ellipse(sin(frameCount * 6) + this.x + this.w - this.w / 4, this.y + this.h / 2.8, this.w / 4, this.h / 4);
    //Health bar
    if (this.health < this.maxHealth) {
        fill(182);
        rect(this.x - 35, this.y - 10, this.maxHealth, 4);
        fill(255, 0, 0);
        rect(this.x - 35, this.y - 10, this.health, 4);
    }
    pushMatrix();
    if(this.dir===0) {
        translate(this.x+this.w+5,this.y);
    } else {
        translate(this.x-5,this.y);    
    }
    scale(0.2);
    noStroke();
    fill(64, 64, 64);
    rect(-100, 0, 195, 8);
    rect(95, -1, 27, 10);
    rect(-100, 13, 217, 8);
    rect(33, -4, 5, 3);
    fill(54, 54, 54);
    rect(58, 11, 1, 12);
    rect(57, 12, 4, 10);
    rect(52, 12, 4, 10);
    rect(46, 12, 4, 10);
    rect(40, 12, 4, 10);
    
    // barrel decorations
    fill(18, 18, 18);
    ellipse(108, -1, 13, 1);
    ellipse(108, 2, 13, 1);
    ellipse(108, 5, 13, 1);
    ellipse(108, 8, 13, 1);
    fill(97, 97, 97);
    rect(-20, -2, 60, 21);
    fill(84, 84, 84);
    rect(-25, -2, 60, 27);
    triangle(35, 15, 35, 25, 42, 20);
    rect(35, 22, 7, 5);
    fill(97, 97, 97);
    triangle(25, 4, 35, 4, 35, 9);
    fill(97, 97, 97);
    rect(-20, -2, 60, 7);
    stroke(51, 51, 51);
    strokeWeight(2);
    line(35, 11, 38, 11);
    line(35, 14, 38, 14);
    noStroke();
    fill(0, 0, 0);
    ellipse(30, 1, 10, 2);
    ellipse(18, 1, 10, 2);
    ellipse(6, 1, 10, 2);
    
    // pump action part decorations
    strokeWeight(1);
    stroke(94, 94, 94);
    line(19, 7, 19, 21);
    line(15, 7, 15, 21);
    line(11, 7, 11, 21);
    line(7, 7, 7, 21);
    line(3, 7, 3, 21);
    noStroke();
    fill(71, 71, 71);
    rect(-5, 24, 15, 3);
    rect(-2, 26, 8, 30);
    stroke(51, 51, 51);
    strokeWeight(1);
    line(-2, 34, 5, 34);
    line(-2, 36, 5, 36);
    line(-2, 38, 5,38);
    line(-2, 40, 5, 40);
    line(-2, 42, 5, 42);
    line(-2, 44, 5, 44);
    line(-2, 46, 5, 46);
    line(-2, 48, 5, 48);
    popMatrix();
};
Gunner.prototype.update = function() {
    if(frameCount%100===99){
        var plrXDist = -(this.x) + plr.x;
        var plrYDist = -(this.y) + plr.y;
        var magnitude = sqrt(sq(plrXDist) + sq(plrYDist));
        addBullet(this.x,
            this.y,
            9,
            plrXDist / magnitude * 5,
            plrYDist / magnitude * 5,
            color(0),
            12, this);
    }
};
var gunners = [];
gunners.add=function(x,y,d){
    this.push(new Gunner(x,y,d));    
};
gunners.apply=function(){
    this.forEach(function(gunner){gunner.draw();gunner.update();});    
};

var gameTxt = function(txt) { 
    fill(0,0,0,gameTxtFade);
    text(txt,300,300);
    gameTxtFade++;
};
var levels = [
    ['        ',
     '       ',
     '        ',
     '        ',
     '        ',
     '        ',
     '        ',
     '        ',
     '        ',
     '        ',
     '        ',
     'P        ',
     '              D',
     '            ',
     'bbbbb   bbbbbbb        '],
     ['',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     'P    ddd      D',
     '     bbb      ',
     'bbb       bbbbbb'],
     ['',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     'P             D',
     '',
     'bbbbbbbbbbbbbbbb'],
     ['',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     '',
     'P             D',
     '     g',
     'bbbbbbbbbbbbbbbb'],
     ['b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b P         D',
     'b  g  bG      b',
    'bbbbbbbbbbbbbbbbbbb'],
    ['b  b',
     'b  b',
     'b  b',
     'b  b',
     'b  b',
     'b  b',
     'b  b',
     'b  b',
     'b  b',
     'b  b',
     'b  b',
     'b  b',
     'b Pb       D',
     'b  l     ',
    'bbbbbbbbbbbbbbbbbbb'],
    ['b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b P         D',
     'b  g  c      b',
    'bbbbbbbbbbbbbbbbbbb'],
    ['b  ',
     'b',
     'b',
     'b         t',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b',
     'b P           D',
     'b  g        b',
    'bbbbbbbbbbbbbbbbbbb']];
var gameMessages = ["You are a professional heister. Use the arrow keys to \n move. Get to the door.","Collect these diamonds to improve your funds. They are\nworth $100 each.", "Remember: You only have 60 seconds to complete each \nlevel.","Whoa! You found a gun! Go ahead and pick it up! Use the\n mouse to aim, and click to shoot.","Your first enemy! It's a cuffer. Be careful! If it \ntouches you, you will be sent back to the beginning\nof the level!","Look! A locked door! Good\n thing you have the tools for\nexactly this occasion! Hold \nX to pick the lock while\nnear it. It takes about 5 \nseconds to pick.","A cannon! Each bullet does a bit of damage, but it\nfires in only one direction. It is, however,\nindestructable."];
objects = [doors,blocks,diamonds,guns,guards, cannons];
objects.remove = function() {
    for (var i = 0; i < objects.length; i++) {
        for (var j = 0; j < objects[i].length; j++) {
            objects[i].splice(j, objects[i].length);
        }
    }
};
loadMap = function() {
    for(var col=0; col<levels[lvl-1].length; col++){
        for(var row=0; row<levels[lvl-1][col].length; row++){
            var i = levels[lvl-1][col][row];
            var ix = row * 40; var iy = col * 40;
            switch(i) {
                case "b" :
                    blocks.add(ix,iy,40,40);
                break;
                case "P" :
                    plr.x = ix; plr.y = iy;
                break; 
                case "d" :
                    diamonds.add(ix,iy,30,30);
                break;    
                case "D" :
                    doors.add(ix,iy);
                break;    
                case "g" :
                    guns.add(ix,iy);
                break;  
                case "G" :
                    guards.add(ix,iy);
                break;    
                case "l" :
                    lockedDoors.add(ix,iy);
                break;
                case "c" :
                    cannons.add(ix,iy);
                break;    
                case "t" :
                    cannons.add(ix,iy,"Following");
                break;
                case "m" :
                    gunners.add(ix,iy);
                break;    
            }    
        }
    }
};    
var getCurrentButtons = function() {
    var buttons;
    switch (scene) {
        case 'splash':
            buttons = drawLogo.buttons;
            break;
        case 'menu':
            buttons = menuBtns;
            break;
    }
    return buttons instanceof Array ? buttons : []; // make sure we're returning an array

};
mouseMoved = mouseOver = function() {
    // find which button is beneath the mouse
    var button = getCurrentButtons().find(function(button) {
        return button.mouseIsOver;
    });
    // set cursor depending on what's beneath it
    cursor(button ? HAND : ARROW);

};

mouseClicked = function() {
    // find which button is beneath the mouse
    var button = getCurrentButtons().find(function(button) {
        return button.mouseIsOver;
    });

    if (button) {
        // perform the action associated with the clicked button
        button.onClick(button);
    } 
    mouseIsClicked = true;
};
var textRainbow = function(t, x, y, s, a, i) {
    pushMatrix();
    translate(x, y);
    rotate(a);
    textSize(s);
    textAlign(CENTER, CENTER);
    colorMode(HSB);
    textFont(createFont("comic sans ms"));
    fill(HeistC%255, 255, 255, i);
    text(t, 0, 0);
    popMatrix();
    colorMode(RGB);
};
loadMap();
var draw = function() {
    frames++;
    if (scene === 'splash') {
        drawLogo();
        if (drawLogo()) {
            changeScene('menu');
        }
    } else if (scene === 'menu') {
        background(255);
        textRainbow("HEIST",300,150,150+sin(frameCount*10)*10,sin(frameCount*5)*10);
        menuBtns.forEach(function(btn) {btn.draw();});
        HeistC++;
    } else if(scene === 'game') {
        background(255);
        fill(0);
        if(lvl >= 2) {
            text("Funds: $" + plr.funds,450,20);
        }
        if(lvl >= 3) {
            text("Time Left: " + timeLeft,120,20);
            timeCnt++;
            if(timeCnt >= 100) {
                timeCnt = 0;
                timeLeft -= 1;
            }
            if(timeLeft <= 0) {
                timeLeft = 60;
                objects.remove();
                loadMap();
            }
        }    
        diamonds.apply();
        blocks.apply();
        doors.apply();
        plr.draw();
        plr.update(blocks,lockedDoors);
        drawBullets();
        updateBullets();
        guns.apply();
        guards.apply();
        lockedDoors.apply();
        cannons.apply();
        for (var i = 0; i < pSystems.length; i++) {
            if (pSystems[i].run()) {
                pSystems.splice(i, 1);
                i--;
            }
        }
        gameTxt(gameMessages[lvl-1]);
        fill(255,0,0,redTrans);
        if(redTrans>0) {
            redTrans-=3;    
        }
        rect(0,0,width,height);
    }     
    mouseIsClicked = false;
};
keyPressed = function() {
    keys[keyCode] = true;
};
keyReleased = function() {
    keys[keyCode] = false;
};

